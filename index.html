<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>VLSI PD Game - Enhanced Physical Design Visualization with CTS Manual & Auto Modes</title>
<style>
  body {
    margin: 0;
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    background-color: #eaeaea;
    user-select: none;
  }
  #topToolbar {
    background: #007acc;
    color: white;
    padding: 6px 15px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
    font-weight: 600;
    user-select: none;
  }
  #topToolbar > div {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    align-items: center;
  }
  #topToolbar button, #topToolbar .toggle-btn {
    cursor: pointer;
    border: none;
    border-radius: 5px;
    padding: 6px 14px;
    font-size: 14px;
    background-color: #059;
    color: white;
    transition: background-color 0.3s ease;
    user-select: none;
  }
  #topToolbar button:hover, #topToolbar .toggle-btn:hover {
    background-color: #005a9e;
  }
  #topToolbar button.active, #topToolbar .toggle-btn.active {
    background-color: #00aaff;
  }
  #container {
    display: flex;
    max-width: 1300px;
    margin: 10px auto;
    gap: 15px;
  }
  #gameArea {
    position: relative;
    border: 1px solid #ccc;
    background: #fefefe;
    box-shadow: 0 0 18px rgba(0,0,0,0.15);
    width: 1200px;
    height: 820px;
  }
  #gameCanvas {
    display: block;
    background: #f9f9f9;
    cursor: crosshair;
    width: 1200px;
    height: 820px;
  }
  #tooltip {
    position: absolute;
    background: rgba(0, 0, 0, 0.85);
    color: white;
    font-size: 13px;
    padding: 4px 8px;
    border-radius: 5px;
    pointer-events: none;
    user-select: none;
    visibility: hidden;
    z-index: 100;
    white-space: nowrap;
  }
  #scoreTime {
    font-weight: 700;
    padding: 10px 14px;
    border-radius: 8px;
    background: #007accd9;
    color: white;
    text-align: center;
    user-select: none;
    position: absolute;
    bottom: 8px;
    left: 8px;
    z-index: 50;
  }
  #counterDisplay {
    position: absolute;
    bottom: 8px;
    right: 8px;
    font-weight: 600;
    color: #555;
    background: #fff;
    padding: 6px 12px;
    border-radius: 7px;
    font-size: 14px;
    box-shadow: 0 0 6px rgba(0,0,0,0.1);
    user-select: none;
    z-index: 50;
  }
  #sidePanel {
    width: 340px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 0 16px rgba(0,0,0,0.15);
    padding: 22px 20px;
    display: flex;
    flex-direction: column;
  }
  h2, h3 {
    margin-top: 0;
    margin-bottom: 14px;
    font-weight: 700;
    color: #222;
  }
  #instructions {
    flex-grow: 1;
    overflow-y: auto;
    font-size: 14px;
    color: #444;
    line-height: 1.5;
    margin-bottom: 22px;
  }
  .btn-group {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 10px;
  }
  .toggle-btn {
    background-color: #cbd6e2;
    color: #2c3e50;
    padding: 5px 10px;
    border-radius: 5px;
    text-align: center;
    font-size: 13px;
    user-select: none;
    min-width: 90px;
  }
  .toggle-btn.active {
    background-color: #125dff;
    color: white;
  }
  /* Scrollbar for instructions */
  #instructions::-webkit-scrollbar {
    width: 8px;
  }
  #instructions::-webkit-scrollbar-track {
    background: #f1f1f1;
  }
  #instructions::-webkit-scrollbar-thumb {
    background: #a3b1c3;
    border-radius: 4px;
  }
  /* Modal for Port Coordinates */
  #portDialogOverlay {
    display: none;
    position: fixed;
    z-index: 110;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.4);
    justify-content: center;
    align-items:center;
  }
  #portDialog {
    background: #fff;
    border-radius: 8px;
    padding: 18px 22px;
    width: 420px;
    box-shadow: 0 0 22px rgba(0,0,0,0.25);
  }
  #portDialog h3 {
    margin-top: 0;
    margin-bottom: 14px;
  }
  label {
    display: block;
    margin-top: 14px;
    margin-bottom: 6px;
    font-weight: 600;
    color: #222;
  }
  input[type=number] {
    width: 70px;
    padding: 6px 10px;
    font-size: 14px;
    border-radius: 5px;
    border: 1px solid #aaa;
  }
  #portDialog button {
    margin-top: 20px;
    background: #007acc;
    color: white;
    border: none;
    padding: 10px 18px;
    font-size: 15px;
    border-radius: 6px;
    cursor: pointer;
    user-select: none;
  }
  #portDialog button:hover {
    background: #005a9e;
  }
  #modeSelector {
    margin: 10px 0 20px 0;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 15px;
  }
  #modeSelector label {
    color: #004080;
    font-weight: 600;
  }
  #modeSelector input[type=radio] {
    margin-right: 6px;
  }
  #layerSelector {
    margin-left: auto;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  #layerSelector label {
    font-weight: 600;
    color: #004080;
  }
  #layerSelector select {
    border-radius: 5px;
    border: 1px solid #aaa;
    padding: 4px 10px;
    font-size: 14px;
  }
  #manualDrawHelp {
    font-size: 13px;
    color: #333;
    margin-top: 8px;
    font-style: italic;
  }
</style>
</head>
<body>

<div id="topToolbar" role="toolbar" aria-label="Stage and Layer Controls" tabindex="0">
  <div aria-label="Stage Navigation">
    <button id="btnSetPorts">Set Port Coordinates</button>
    <button id="btnMacro" class="active" title="Macro Placement Stage">Macro Placement</button>
    <button id="btnPowerPlan" title="Power Plan Stage">Power Plan</button>
    <button id="btnStdManual" title="Standard Cell Manual Placement">StdCell Manual</button>
    <button id="btnStdAuto" title="Standard Cell Auto Placement">StdCell Auto</button>
    <button id="btnCTSManual" title="Clock Tree Synthesis Manual">CTS Manual</button>
    <button id="btnCTSAuto" title="Clock Tree Synthesis Automatic">CTS Auto</button>
    <button id="btnRouteManual" title="Routing Manual">Routing Manual</button>
    <button id="btnRouteAuto" title="Routing Automatic">Routing Auto</button>
  </div>
  <div aria-label="Metal Layer and Via Visibility" style="margin-left:auto; display:flex; gap:10px; flex-wrap:wrap; max-width: 600px;">
    <button class="toggle-btn active" data-layer="all" title="Toggle All Layers and Vias">All</button>
    <button class="toggle-btn active" data-layer="M1" title="Toggle Metal 1 (Power rails)">Metal 1</button>
    <button class="toggle-btn active" data-layer="M2" title="Toggle Metal 2 (Power rails)">Metal 2</button>
    <button class="toggle-btn active" data-layer="M3" title="Toggle Metal 3 (Data routing)">Metal 3</button>
    <button class="toggle-btn active" data-layer="M4" title="Toggle Metal 4 (Vertical clock)">Metal 4</button>
    <button class="toggle-btn active" data-layer="M5" title="Toggle Metal 5 (Horizontal clock)">Metal 5</button>
    <button class="toggle-btn active" data-layer="M6" title="Toggle Metal 6 (Vertical power)">Metal 6</button>
    <button class="toggle-btn active" data-layer="M7" title="Toggle Metal 7 (Global power)">Metal 7</button>
    <button class="toggle-btn active" data-layer="via01" title="Toggle Via 01 (M1-M2)">Via 01</button>
    <button class="toggle-btn active" data-layer="via12" title="Toggle Via 12 (M2-M3)">Via 12</button>
    <button class="toggle-btn active" data-layer="via23" title="Toggle Via 23 (M3-M4)">Via 23</button>
    <button class="toggle-btn active" data-layer="via34" title="Toggle Via 34 (M4-M5)">Via 34</button>
    <button class="toggle-btn active" data-layer="via45" title="Toggle Via 45 (M5-M6)">Via 45</button>
    <button class="toggle-btn active" data-layer="via56" title="Toggle Via 56 (M6-M7)">Via 56</button>
  </div>
</div>

<div id="container">
  <div id="gameArea" aria-label="VLSI Physical Design Canvas Area">
    <canvas id="gameCanvas" width="1200" height="820" tabindex="0" role="graphics-document" aria-label="VLSI physical design canvas"></canvas>
    <div id="tooltip"></div>
    <div id="scoreTime" aria-live="polite">Score: 0 | Time: 0s | Stage: Macro Placement</div>
    <div id="counterDisplay" aria-live="polite">Macros: 0 | StdCells: 0</div>
  </div>
  <div id="sidePanel" aria-live="polite" aria-atomic="true">
    <h2>VLSI PD Game Stages & Guidelines</h2>
    <div id="modeSelector" style="display:none;">
      <label>Mode:</label>
      <label><input type="radio" name="mode" value="automatic" checked> Automatic</label>
      <label><input type="radio" name="mode" value="manual"> Manual</label>
      <div id="layerSelector" style="display:none;">
        <label for="metalLayerSelect">Select Metal Layer:</label>
        <select id="metalLayerSelect" aria-label="Select metal layer for manual drawing">
          <!-- dynamically populated -->
        </select>
      </div>
    </div>
    <div id="manualDrawHelp" style="display:none;">
      Click to add points for manual routing.<br>
      Lines will be constrained: Horizontal layers draw horizontal lines; Vertical layers draw vertical lines.<br>
      Double-click to finish the current route.
    </div>
    <div id="instructions">
      <p><strong>Stage Flow:</strong></p>
      <ol>
        <li><b>Set Port Coordinates: </b> Click "Set Port Coordinates" to move all ports (VDD, VSS, CLK, DATA) freely on left side before placement starts.</li>
        <li><b>Macro Placement (Floorplan):</b> Drag yellow macro blocks inside the CORE region. Macros have 4 pins (VDD, VSS, CLK, SIGNAL) aligned to power and clock grids.</li>
        <li><b>Power Plan:</b> View 7 metal layers and vias with toggles. Power rails on M1-M3 and M6-M7, clock uses M4-M5.</li>
        <li><b>Standard Cell Placement:</b> Blue std cells appear in rows. All blocks have 4 pins (VDD, VSS, CLK, SIGNAL).</li>
        <li><b>Clock Tree Synthesis (CTS):</b> CTS routes clock nets ONLY on M4 (vertical) and M5 (horizontal). Manual mode allows manual CTS routing with layer selection and constrained drawing.</li>
        <li><b>Signal Routing:</b> Signal nets routed exactly like clock tree on M3 (horizontal) and M2 (vertical) layers.</li>
        <li><b>Routing:</b> Final stage routes all SIGNAL pins to DATA port automatically or manually using layer-specific constrained drawing.</li>
      </ol>
      <p><strong>Tooltips:</strong> Hover over metal layers or pins to see layer and net type like "M5 CLK" or "M3 DATA".</p>
    </div>
  </div>
</div>

<!-- Modal dialog for Port Coordinate setting -->
<div id="portDialogOverlay" role="dialog" aria-modal="true" aria-labelledby="portDialogTitle">
  <div id="portDialog">
    <h3 id="portDialogTitle">Set Port Coordinates (Left Side)</h3>
    <form id="portForm" novalidate>
      <div>
        <label for="vddX">VDD X:</label>
        <input type="number" id="vddX" name="vddX" min="0" max="300" required>
        <label for="vddY">VDD Y:</label>
        <input type="number" id="vddY" name="vddY" min="0" max="820" required>
      </div>
      <div>
        <label for="vssX">VSS X:</label>
        <input type="number" id="vssX" name="vssX" min="0" max="300" required>
        <label for="vssY">VSS Y:</label>
        <input type="number" id="vssY" name="vssY" min="0" max="820" required>
      </div>
      <div>
        <label for="clkX">CLK X:</label>
        <input type="number" id="clkX" name="clkX" min="0" max="300" required>
        <label for="clkY">CLK Y:</label>
        <input type="number" id="clkY" name="clkY" min="0" max="820" required>
      </div>
      <div>
        <label for="dataX">DATA X:</label>
        <input type="number" id="dataX" name="dataX" min="0" max="300" required>
        <label for="dataY">DATA Y:</label>
        <input type="number" id="dataY" name="dataY" min="0" max="820" required>
      </div>
      <button type="submit" id="applyPortsBtn">Apply & Close</button>
    </form>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const tooltip = document.getElementById("tooltip");
  const scoreTime = document.getElementById("scoreTime");
  const counterDisplay = document.getElementById("counterDisplay");
  const portDialogOverlay = document.getElementById("portDialogOverlay");
  const portForm = document.getElementById("portForm");

  const modeSelector = document.getElementById("modeSelector");
  const manualDrawHelp = document.getElementById("manualDrawHelp");
  const metalLayerSelect = document.getElementById("metalLayerSelect");

  // Core design region (floorplan)
  const core = { x: 320, y: 150, w: 820, h: 600 };
  const macroW = 80;
  const macroH = 80;
  const stdCellHeight = Math.max(10, Math.round(macroH / 8)); // ~1/8 of macro height for pin stacking
  const stdCellWidth = 50;
  const pitch = stdCellHeight;

  // State
  let stage = "macroPlacement";
  let score = 0;
  let time = 0;
  let timerInterval = null;

  // MACROS and STDCELLS data (position, dimensions, pins)
  let macros = [
    { x: 340, y: 160, w: macroW, h: macroH, color: "yellow", label: "Macro 1" },
    { x: 440, y: 160, w: macroW, h: macroH, color: "yellow", label: "Macro 2" },
    { x: 540, y: 160, w: macroW, h: macroH, color: "yellow", label: "Macro 3" },
    { x: 640, y: 160, w: macroW, h: macroH, color: "yellow", label: "Macro 4" },
  ];
  let stdCells = [];
  for (let i = 0; i < 25; i++) {
    stdCells.push({ x: -100, y: -100, w: stdCellWidth, h: stdCellHeight, color: "#2080d0", label: `StdCell ${i + 1}` });
  }

  // PORTS - coordinates configurable, all on left side before placement stage
  let powerPorts = [
    { x: 200, y: 140, w: 40, h: 20, color: "#d22", label: "VDD Port", net: "VDD" },
    { x: 200, y: 180, w: 40, h: 20, color: "#292", label: "VSS Port", net: "VSS" }
  ];
  let clockPort = { x: 200, y: 220, w: 40, h: 40, color: "#22f", label: "Clock Port", net: "CLK" };
  let dataPorts = [{ x: 200, y: 270, w: 40, h: 25, color: "#000", label: "DATA Port", net: "DATA" }];

  // Metal and via layer definitions with color + width and orientation
  const metalLayers = [
    { name: "M7", color: "#d22", orientation: "horizontal", width: 10 },
    { name: "M6", color: "#e67e22", orientation: "vertical", width: 7 },
    { name: "M5", color: "#297ab9", orientation: "horizontal", width: 6 },
    { name: "M4", color: "#2ea15a", orientation: "vertical", width: 5 },
    { name: "M3", color: "#8e44ad", orientation: "horizontal", width: 3 },
    { name: "M2", color: "#2080d0", orientation: "vertical", width: 3 },
    { name: "M1", color: "#1abc9c", orientation: "horizontal", width: 2 }
  ];

  const viaLayers = [
    { name: "via01", color: "#b33939" },
    { name: "via12", color: "#b37439" },
    { name: "via23", color: "#6272a4" },
    { name: "via34", color: "#2d928d" },
    { name: "via45", color: "#674172" },
    { name: "via56", color: "#6e2e1f" }
  ];

  let layerVisibility = {
    all: true,
    M1: true, M2: true, M3: true, M4: true, M5: true, M6: true, M7: true,
    via01: true, via12: true, via23: true, via34: true, via45: true, via56: true
  };

  let metalTrunks = {};
  let viaLocations = {};

  let routedPowerTracks = { VDD: [], VSS: [] };
  let routedCTSNetwork = [];  // clock routes on M4 (vertical) and M5 (horizontal) only
  let routedDataNetwork = []; // signal routes on M2 (vertical) and M3 (horizontal) only

  // For manual CTS routing on selected layers (user drawn lines)
  let manualCTSRoutes = [];
  let manualRoutePoints = [];
  let manualDrawing = false;
  let manualDrawingStage = null; // 'ctsManual' or 'routingManual'
  let manualActiveLayer = null;

  // Initialize metal trunks + vias (static grids)
  function initializeGridAndVias() {
    metalTrunks = {};
    viaLocations = {};
    // M7 horizontal, pitch 50
    metalTrunks["M7"] = [];
    for (let y = core.y; y <= core.y + core.h; y += 50)
      metalTrunks["M7"].push({ x1: core.x, y1: y, x2: core.x + core.w, y2: y });
    // M6 vertical, pitch 50
    metalTrunks["M6"] = [];
    for (let x = core.x; x <= core.x + core.w; x += 50)
      metalTrunks["M6"].push({ x1: x, y1: core.y, x2: x, y2: core.y + core.h });

    // M5 horizontal, pitch 60 + offset 20
    metalTrunks["M5"] = [];
    for (let y = core.y; y <= core.y + core.h; y += 60)
      metalTrunks["M5"].push({ x1: core.x, y1: y + 20, x2: core.x + core.w, y2: y + 20 });

    // M4 vertical, pitch 70 + offset 20
    metalTrunks["M4"] = [];
    for (let x = core.x; x <= core.x + core.w; x += 70)
      metalTrunks["M4"].push({ x1: x + 20, y1: core.y, x2: x + 20, y2: core.y + core.h });

    // M3 horizontal pitch spacing + offset pitch/3 for signal routing
    metalTrunks["M3"] = [];
    for (let y = core.y; y <= core.y + core.h; y += pitch)
      metalTrunks["M3"].push({ x1: core.x, y1: y + pitch / 3, x2: core.x + core.w, y2: y + pitch / 3 });

    // M2 vertical rails spaced stdCellWidth * 2 for signal routing
    metalTrunks["M2"] = [];
    for (let x = core.x; x <= core.x + core.w; x += stdCellWidth * 2)
      metalTrunks["M2"].push({ x1: x, y1: core.y, x2: x, y2: core.y + core.h });

    // M1 horizontal rails every pitch for power pins stacking
    metalTrunks["M1"] = [];
    for (let y = core.y; y <= core.y + core.h; y += pitch)
      metalTrunks["M1"].push({ x1: core.x, y1: y, x2: core.x + core.w, y2: y });

    // Via grid along intersections for each via layer
    const createViasBetweenGrids = (layer1, layer2, pitchX, pitchY, offsetX = 0, offsetY = 0) => {
      const vias = [];
      let cnt = 0;
      for (let y = core.y; y <= core.y + core.h; y += pitchY) {
        for (let x = core.x; x <= core.x + core.w; x += pitchX) {
          vias.push({ x: x + offsetX, y: y + offsetY, id: `${layer1}${layer2}_${cnt++}` });
        }
      }
      return vias;
    };

    viaLocations["via56"] = createViasBetweenGrids("5", "6", 50, 50);
    viaLocations["via45"] = createViasBetweenGrids("4", "5", 50, 60, 0, 20);
    viaLocations["via34"] = createViasBetweenGrids("3", "4", 70, 60, 20, 20);
    viaLocations["via23"] = createViasBetweenGrids("2", "3", 70, pitch, 20, pitch / 3);
    viaLocations["via12"] = createViasBetweenGrids("1", "2", stdCellWidth * 2, pitch, 0, pitch / 3);
    viaLocations["via01"] = createViasBetweenGrids("0", "1", stdCellWidth * 2, pitch, 0, 0);
  }

  // UI helpers
  function isInsideCore(b) {
    return b.x >= core.x && b.y >= core.y && b.x + b.w <= core.x + core.w && b.y + b.h <= core.y + core.h;
  }
  function snapToGrid(v) {
    return Math.round(v / pitch) * pitch;
  }

  function updateStatus() {
    const stageLabel = ({
      macroPlacement: "Macro Placement",
      powerPlan: "Power Plan",
      stdCellManual: "StdCell Manual",
      stdCellAuto: "StdCell Auto",
      ctsManual: "CTS Manual",
      ctsAuto: "CTS Auto",
      routingManual: "Routing Manual",
      routingAuto: "Routing Auto"
    })[stage] || stage;

    scoreTime.textContent = `Score: ${score} | Time: ${time}s | Stage: ${stageLabel}`;

    const macroCount = macros.filter(isInsideCore).length;
    const stdCellCount = stdCells.filter(isInsideCore).length;
    counterDisplay.textContent = `Macros: ${macroCount} | StdCells: ${stdCellCount}`;
  }

  // Stage button elements
  const btnSetPorts = document.getElementById("btnSetPorts");
  const btnMacro = document.getElementById("btnMacro");
  const btnPowerPlan = document.getElementById("btnPowerPlan");
  const btnStdManual = document.getElementById("btnStdManual");
  const btnStdAuto = document.getElementById("btnStdAuto");
  const btnCTSManual = document.getElementById("btnCTSManual");
  const btnCTSAuto = document.getElementById("btnCTSAuto");
  const btnRouteManual = document.getElementById("btnRouteManual");
  const btnRouteAuto = document.getElementById("btnRouteAuto");
  const layerButtons = document.querySelectorAll("#topToolbar .toggle-btn");

  function clearActiveButtons() {
    [btnMacro, btnPowerPlan, btnStdManual, btnStdAuto, btnCTSManual, btnCTSAuto, btnRouteManual, btnRouteAuto].forEach(b => {
      b.classList.remove("active");
    });
  }

  function updateLayerButtons() {
    let allOn = true;
    for (const key in layerVisibility) {
      if (key === "all") continue;
      if (!layerVisibility[key]) allOn = false;
    }
    layerVisibility.all = allOn;
    layerButtons.forEach(btn => {
      if (layerVisibility[btn.dataset.layer]) {
        btn.classList.add("active");
      } else {
        btn.classList.remove("active");
      }
    });
  }

  function selectStage(s) {
    clearActiveButtons();
    switch (s) {
      case "macroPlacement":
        btnMacro.classList.add("active");
        stage = "macroPlacement";
        modeSelector.style.display = "none";
        manualDrawHelp.style.display = "none";
        break;
      case "powerPlan":
        btnPowerPlan.classList.add("active");
        stage = "powerPlan";
        modeSelector.style.display = "none";
        manualDrawHelp.style.display = "none";
        break;
      case "stdManual":
        btnStdManual.classList.add("active");
        stage = "stdCellManual";
        modeSelector.style.display = "none";
        manualDrawHelp.style.display = "none";
        autoPlaceStdCellsNearMacros();
        break;
      case "stdAuto":
        btnStdAuto.classList.add("active");
        stage = "stdCellAuto";
        modeSelector.style.display = "none";
        manualDrawHelp.style.display = "none";
        autoPlaceStdCellsNearMacros();
        break;
      case "ctsManual":
        btnCTSManual.classList.add("active");
        stage = "ctsManual";
        enableModeSelector(true);
        manualDrawingStage = "ctsManual";
        manualDrawHelp.style.display = "block";
        break;
      case "ctsAuto":
        btnCTSAuto.classList.add("active");
        stage = "ctsAuto";
        enableModeSelector(false);
        manualDrawHelp.style.display = "none";
        break;
      case "routingManual":
        btnRouteManual.classList.add("active");
        stage = "routingManual";
        enableModeSelector(true);
        manualDrawingStage = "routingManual";
        manualDrawHelp.style.display = "block";
        break;
      case "routingAuto":
        btnRouteAuto.classList.add("active");
        stage = "routingAuto";
        enableModeSelector(false);
        manualDrawHelp.style.display = "none";
        break;
    }
    score = 0;
    time = 0;
    timerStart();
    if (stage === "powerPlan") {
      routePowerNets();
    }
    if (stage === "ctsAuto") {
      buildClockTree();
      filterLayersForCTS();
    }
    if (stage === "ctsManual") {
      buildClockTree();
      filterLayersForCTS();
      manualCTSRoutes = [];
      manualRoutePoints = [];
      manualDrawing = false;
      manualActiveLayer = metalLayerSelect.value;
    }
    if (stage === "routingAuto") {
      buildSignalTree();
      routeSignalNets();
      filterLayersForSignal();
    }
    if (stage === "routingManual") {
      buildSignalTree();
      manualCTSRoutes = [];
      manualRoutePoints = [];
      manualDrawing = false;
      manualActiveLayer = metalLayerSelect.value;
      filterLayersForSignal();
    }
    drawAll();
  }

  // Populate metal layer selector for manual routing (only metal layers, no power layers)
  function populateMetalLayerSelect() {
    metalLayerSelect.innerHTML = "";
    // For CTS routing: only M4 (vertical) and M5 (horizontal)
    // For routingManual stage: M2 (vertical), M3 (horizontal)
    const applicableLayers = (manualDrawingStage === "ctsManual") ? ["M4", "M5"] :
                             (manualDrawingStage === "routingManual") ? ["M2", "M3"] : [];
    applicableLayers.forEach(l => {
      const opt = document.createElement("option");
      opt.value = l;
      opt.textContent = `${l} (${metalLayers.find(v => v.name === l).orientation})`;
      metalLayerSelect.appendChild(opt);
    });
    if (metalLayerSelect.options.length > 0) {
      manualActiveLayer = metalLayerSelect.value;
      metalLayerSelect.disabled = false;
    } else {
      manualActiveLayer = null;
      metalLayerSelect.disabled = true;
    }
  }

  // Enable or disable mode selector for manual/auto choices
  function enableModeSelector(enable) {
    modeSelector.style.display = enable ? "flex" : "none";
    if(enable) {
      // Setup default mode radio checked
      const autoRadio = modeSelector.querySelector('input[value="automatic"]');
      const manualRadio = modeSelector.querySelector('input[value="manual"]');
      if (autoRadio) autoRadio.checked = true;
      manualDrawHelp.style.display = "none";
    }
  }

  // Selectors for mode input radios
  modeSelector.querySelectorAll("input[name='mode']").forEach(radio => {
    radio.addEventListener("change", e => {
      if(e.target.checked) {
        if(e.target.value === "manual") {
          populateMetalLayerSelect();
          document.getElementById("layerSelector").style.display = "flex";
          manualDrawHelp.style.display = "block";
          manualDrawing = false;
          manualRoutePoints = [];
          manualCTSRoutes = [];
          manualActiveLayer = metalLayerSelect.value;
        } else {
          // Automatic mode - clear manual routes and rerun automatic routing
          manualDrawHelp.style.display = "none";
          document.getElementById("layerSelector").style.display = "none";
          manualDrawing = false;
          manualRoutePoints = [];
          manualCTSRoutes = [];
          if(stage === "ctsManual" || stage === "ctsAuto"){
            // Auto rerun the CTS auto build
            buildClockTree();
            filterLayersForCTS();
          }
          if(stage === "routingManual" || stage === "routingAuto"){
            buildSignalTree();
            routeSignalNets();
            filterLayersForSignal();
          }
        }
        drawAll();
      }
    });
  });

  // Layer select change for manual drawing layer
  metalLayerSelect.addEventListener("change", e => {
    manualActiveLayer = e.target.value;
  });

  // Button listeners for stages
  btnSetPorts.onclick = () => { openPortDialog(); };
  btnMacro.onclick = () => selectStage("macroPlacement");
  btnPowerPlan.onclick = () => selectStage("powerPlan");
  btnStdManual.onclick = () => selectStage("stdManual");
  btnStdAuto.onclick = () => selectStage("stdAuto");
  btnCTSManual.onclick = () => selectStage("ctsManual");
  btnCTSAuto.onclick = () => selectStage("ctsAuto");
  btnRouteManual.onclick = () => selectStage("routingManual");
  btnRouteAuto.onclick = () => selectStage("routingAuto");

  // Layer toggle listeners
  layerButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      const layer = btn.dataset.layer;
      if (layer === "all") {
        const newVal = !layerVisibility.all;
        for (const k in layerVisibility) {
          if (k !== "all") layerVisibility[k] = newVal;
        }
        layerVisibility.all = newVal;
      } else {
        layerVisibility[layer] = !layerVisibility[layer];
        // If user toggles off layers manually, "all" should reflect that
        layerVisibility.all = Object.keys(layerVisibility).filter(l => l !== "all").every(l => layerVisibility[l]);
      }
      updateLayerButtons();
      drawAll();
    });
  });
  updateLayerButtons();

  // Auto-place std cells near macros for placement stages
  function autoPlaceStdCellsNearMacros() {
    let minX = Infinity, maxX = -Infinity, minY = Infinity;
    macros.forEach(m => {
      if (m.x < minX) minX = m.x;
      if (m.x + m.w > maxX) maxX = m.x + m.w;
      if (m.y < minY) minY = m.y;
    });
    let startX = maxX + 10;
    if (startX + stdCellWidth > core.x + core.w) startX = minX;
    let startY = minY;

    const perRow = 6;
    let row = 0, col = 0;
    for (let i = 0; i < stdCells.length; i++) {
      let x = startX + col * stdCellWidth;
      let y = startY + row * stdCellHeight;
      if (x + stdCellWidth > core.x + core.w) {
        x = startX;
        row++;
        y = startY + row * stdCellHeight;
      }
      if (y + stdCellHeight > core.y + core.h) y = core.y + core.h - stdCellHeight - 8;
      stdCells[i].x = x;
      stdCells[i].y = y;
      col++;
      if (col >= perRow) {
        col = 0;
        row++;
      }
    }
  }

  // ----- Drawing and Routing Helpers -----

  // Clear canvas and draw all components: core, grid, ports, blocks, routing layers
  function drawAll() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw core bounding box and grid background
    ctx.fillStyle = "#ddd";
    ctx.fillRect(core.x, core.y, core.w, core.h);
    ctx.strokeStyle = "#444";
    ctx.lineWidth = 4;
    ctx.strokeRect(core.x, core.y, core.w, core.h);

    // Grid lines inside core (pitch)
    ctx.strokeStyle = "#bbb";
    ctx.lineWidth = 1;
    for (let y = core.y; y <= core.y + core.h; y += pitch) {
      ctx.beginPath();
      ctx.moveTo(core.x, y);
      ctx.lineTo(core.x + core.w, y);
      ctx.stroke();
    }
    for (let x = core.x; x <= core.x + core.w; x += pitch) {
      ctx.beginPath();
      ctx.moveTo(x, core.y);
      ctx.lineTo(x, core.y + core.h);
      ctx.stroke();
    }

    // Draw metal layers and vias depending on stage and layer visibility & filtered layers

    if (stage === "powerPlan") {
      drawAllMetalLayers();
      drawAllViaLayers();
      drawPortBlocks();
      drawBlocks();
      drawPowerNetTracks();
    }
    else if (stage === "ctsAuto" || stage === "ctsManual") {
      drawAllMetalLayers();
      drawAllViaLayers();
      drawPortBlocks();
      drawBlocks();
      drawPowerNetTracks();
      if(stage === "ctsAuto") drawCTSNetwork();
      else drawManualCTSNetwork();
    }
    else if (stage === "routingAuto" || stage === "routingManual") {
      drawAllMetalLayers();
      drawAllViaLayers();
      drawPortBlocks();
      drawBlocks();
      drawPowerNetTracks();
      drawCTSNetwork();
      if(stage === "routingAuto") drawSignalNetwork();
      else drawManualCTSNetwork(); // also reuse manual draw for routingManual for signals
    }
    else {
      drawPortBlocks();
      drawBlocks();
      drawPowerNetTracks();
      drawCTSNetwork();
      drawSignalNetwork();
    }

    updateStatus();
  }

  // Draw all macros and std cells blocks with pins
  function drawBlocks() {
    macros.forEach(b => drawBlockWithPins(b));
    stdCells.forEach(b => drawBlockWithPins(b));
  }

  // Draw all ports (powerPorts, clock, data)
  function drawPortBlocks() {
    powerPorts.forEach(p => drawPortBlock(p));
    drawBlockWithPins(clockPort);
    dataPorts.forEach(p => drawPortBlock(p));
  }

  // Draw generic port rectangle with label
  function drawPortBlock(p) {
    ctx.fillStyle = p.color;
    ctx.strokeStyle = "#222";
    ctx.lineWidth = 2;
    ctx.fillRect(p.x, p.y, p.w, p.h);
    ctx.strokeRect(p.x, p.y, p.w, p.h);
    ctx.fillStyle = "white";
    ctx.font = "13px Arial";
    ctx.textAlign = "center";
    ctx.fillText(p.label, p.x + p.w / 2, p.y + p.h / 2 + 6);
  }

  // Draw block rectangle with 4 pins (VDD, VSS, CLK, SIGNAL)
  function drawBlockWithPins(block) {
    ctx.fillStyle = block.color;
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 2;
    ctx.fillRect(block.x, block.y, block.w, block.h);
    ctx.strokeRect(block.x, block.y, block.w, block.h);

    ctx.fillStyle = "#222";
    ctx.font = block.w < 55 ? "10px Arial" : "14px Arial";
    ctx.textAlign = "center";
    ctx.fillText(block.label, block.x + block.w / 2, block.y + block.h / 2 + 6);

    drawPinsForBlock(block);
  }

  // Draw 4 pins on block: VDD, VSS (top), CLK (left vertical), SIGNAL (right vertical)
  function drawPinsForBlock(block) {
    // Show pins only if M1 visible (lowest metal for stacking)
    if (!layerVisibility["M1"]) return;

    const pinWidth = block.w * 0.3;
    const pinHeight = stdCellHeight / 8;

    // VDD pin (top center, red)
    const vddX = block.x + block.w * 0.35;
    const vddY = block.y - pinHeight * 1.5;
    ctx.fillStyle = "red";
    ctx.fillRect(vddX, vddY, pinWidth, pinHeight);
    drawViaStack(vddX + pinWidth / 2, vddY + pinHeight / 2, "VDD");

    // VSS pin (top right next to VDD, green)
    const vssY = block.y - pinHeight * 0.4;
    ctx.fillStyle = "green";
    ctx.fillRect(vddX, vssY, pinWidth, pinHeight);
    drawViaStack(vddX + pinWidth / 2, vssY + pinHeight / 2, "VSS");

    // CLK pin vertical left bar (blue)
    const clkX = block.x - pinHeight * 1.1;
    const clkY = block.y - pinHeight * 1.5;
    ctx.fillStyle = "blue";
    ctx.fillRect(clkX, clkY, pinHeight * 1.2, pinHeight * 4);
    drawViaStack(clkX + pinHeight * 0.6, clkY + pinHeight, "CLK");

    // SIGNAL pin vertical right bar (black)
    const sigX = block.x + block.w + 3;
    const sigY = block.y - pinHeight * 1.5;
    ctx.fillStyle = "black";
    ctx.fillRect(sigX, sigY, pinHeight * 1.2, pinHeight * 4);
    drawViaStack(sigX + pinHeight * 0.6, sigY + pinHeight, "SIGNAL");
  }

  // Draw stack of 3 small circles for vias on pins
  function drawViaStack(cx, cy, netType) {
    if (!layerVisibility["via01"]) return;
    ctx.fillStyle = {
      VDD: "#b33939",
      VSS: "#329932",
      CLK: "#2e7bd1",
      SIGNAL: "#000000"
    }[netType] || "#222";
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.arc(cx, cy - i * 6, 3, 0, 2 * Math.PI);
      ctx.fill();
    }
  }

  // Draw metal trunks of a given layer if visible
  function drawMetalLayer(layerName) {
    if (!layerVisibility[layerName]) return;
    const layerDef = metalLayers.find(l => l.name === layerName);
    if (!layerDef) return;
    ctx.strokeStyle = layerDef.color;
    ctx.lineCap = "round";
    ctx.lineWidth = layerDef.width;
    const segs = metalTrunks[layerName] || [];
    segs.forEach(({ x1, y1, x2, y2 }) => {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    });
  }

  // Draw all metal layers in order M1-M7
  function drawAllMetalLayers() {
    metalLayers.forEach(layer => drawMetalLayer(layer.name));
  }

  // Draw vias layer if visible (colored circles with id label)
  function drawViaLayer(viaName) {
    if (!layerVisibility[viaName]) return;
    const viaDef = viaLayers.find(v => v.name === viaName);
    if (!viaDef) return;
    const vias = viaLocations[viaName] || [];
    ctx.fillStyle = viaDef.color;
    ctx.font = "8px monospace";
    ctx.textAlign = "center";
    vias.forEach(({ x, y, id }) => {
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, 2 * Math.PI);
      ctx.fill();
      ctx.fillStyle = "#111";
      ctx.fillText(id, x, y + 14);
      ctx.fillStyle = viaDef.color;
    });
  }
  function drawAllViaLayers() {
    viaLayers.forEach(via => drawViaLayer(via.name));
  }

  // Routing logic

  // Route power nets from power ports to blocks on M7-M6-M2
  function routePowerNets() {
    routedPowerTracks = { VDD: [], VSS: [] };
    powerPorts.forEach(port => {
      let net = port.net;
      const m7Trunks = metalTrunks["M7"];
      if (!m7Trunks || m7Trunks.length === 0) return;
      const portCenterY = port.y + port.h / 2;
      const closestM7 = m7Trunks.reduce((prev, curr) => Math.abs(curr.y1 - portCenterY) < Math.abs(prev.y1 - portCenterY) ? curr : prev);
      const portCenterX = port.x + port.w / 2;
      routedPowerTracks[net].push({
        layer: "M7",
        points: [
          { x: portCenterX, y: portCenterY },
          { x: portCenterX, y: closestM7.y1 },
          { x: closestM7.x1, y: closestM7.y1 },
          { x: closestM7.x2, y: closestM7.y2 }
        ]
      });
    });
    const connectBlockPowerPin = (block, net) => {
      if (!isInsideCore(block)) return;
      let pinX = block.x + block.w * 0.5;
      let pinY = net === "VDD" ? block.y - stdCellHeight / 8 * 1.5 : block.y - stdCellHeight / 8 * 0.4;

      const m7Trunks = metalTrunks["M7"];
      const m6Trunks = metalTrunks["M6"];
      const m2Trunks = metalTrunks["M2"];
      if (!m7Trunks || !m6Trunks || !m2Trunks) return;

      const closestM7 = m7Trunks.reduce((prev, curr) => Math.abs(curr.y1 - pinY) < Math.abs(prev.y1 - pinY) ? curr : prev);
      const closestM6 = m6Trunks.reduce((prev, curr) => Math.abs(curr.x1 - pinX) < Math.abs(prev.x1 - pinX) ? curr : prev);
      const closestM2 = m2Trunks.reduce((prev, curr) => Math.abs(curr.x1 - pinX) < Math.abs(prev.x1 - pinX) ? curr : prev);

      const points = [
        { x: pinX, y: pinY },
        { x: closestM2.x1, y: pinY },
        { x: closestM2.x1, y: core.y },
        { x: closestM6.x1, y: core.y },
        { x: closestM6.x1, y: closestM7.y1 },
        { x: closestM7.x2, y: closestM7.y2 }
      ];

      routedPowerTracks[net].push({ layer: "M2->M6->M7", points });
    };

    [...macros, ...stdCells].forEach(b => {
      connectBlockPowerPin(b, "VDD");
      connectBlockPowerPin(b, "VSS");
    });
  }

  // Build balanced clock tree on M4 and M5 from clock port to all block clock pins
  function buildClockTree() {
    routedCTSNetwork = [];
    const sinks = [...macros, ...stdCells].filter(isInsideCore)
      .map(b => ({ x: b.x, y: b.y + b.h / 2, block: b }));

    const root = { x: clockPort.x + clockPort.w / 2, y: clockPort.y + clockPort.h / 2 };

    function recursiveCTS(points, rootNode, depth = 0) {
      if (points.length === 0) return;
      if (points.length === 1) {
        routedCTSNetwork.push({
          layer: depth % 2 === 0 ? "M5" : "M4",
          points: manhattanPath(rootNode, points[0])
        });
        return;
      }
      const horizontal = (depth % 2 === 0);
      const coord = horizontal ? "x" : "y";
      points.sort((a, b) => a[coord] - b[coord]);
      const mid = Math.floor(points.length / 2);
      const leftPoints = points.slice(0, mid);
      const rightPoints = points.slice(mid);

      let branchPoint;
      if (horizontal)
        branchPoint = { x: points[mid][coord], y: rootNode.y };
      else
        branchPoint = { x: rootNode.x, y: points[mid][coord] };

      routedCTSNetwork.push({
        layer: horizontal ? "M5" : "M4",
        points: manhattanPath(rootNode, branchPoint)
      });
      recursiveCTS(leftPoints, branchPoint, depth + 1);
      recursiveCTS(rightPoints, branchPoint, depth + 1);
    }

    recursiveCTS(sinks, root);
  }

  // Build balanced signal (DATA) tree on M3 and M2 from DATA port to all blocks' signal pins
  function buildSignalTree() {
    routedDataNetwork = [];
    const sinks = [...macros, ...stdCells].filter(isInsideCore)
      .map(b => ({ x: b.x + b.w + 12, y: b.y + b.h / 2, block: b }));

    const root = { x: dataPorts[0].x + dataPorts[0].w / 2, y: dataPorts[0].y + dataPorts[0].h / 2 };

    function recursiveSig(points, rootNode, depth = 0) {
      if (points.length === 0) return;
      if (points.length === 1) {
        routedDataNetwork.push({
          layer: depth % 2 === 0 ? "M3" : "M2",
          points: manhattanPath(rootNode, points[0])
        });
        return;
      }
      const horizontal = (depth % 2 === 0);
      const coord = horizontal ? "x" : "y";
      points.sort((a, b) => a[coord] - b[coord]);
      const mid = Math.floor(points.length / 2);
      const leftPoints = points.slice(0, mid);
      const rightPoints = points.slice(mid);

      let branchPoint;
      if (horizontal)
        branchPoint = { x: points[mid][coord], y: rootNode.y };
      else
        branchPoint = { x: rootNode.x, y: points[mid][coord] };

      routedDataNetwork.push({
        layer: horizontal ? "M3" : "M2",
        points: manhattanPath(rootNode, branchPoint)
      });
      recursiveSig(leftPoints, branchPoint, depth + 1);
      recursiveSig(rightPoints, branchPoint, depth + 1);
    }

    recursiveSig(sinks, root);
  }

  // Route signal nets (already built by buildSignalTree)
  function routeSignalNets() {
    // No changes needed here; routedDataNetwork is built in buildSignalTree.
  }

  // Manhattan path helper: {x, y}
  function manhattanPath(src, dst) {
    return [{ x: src.x, y: src.y }, { x: dst.x, y: src.y }, { x: dst.x, y: dst.y }];
  }

  // Draw power net tracks (VDD, VSS) lines
  function drawPowerNetTracks() {
    ["VDD", "VSS"].forEach(net => {
      routedPowerTracks[net].forEach(track => {
        const baseLayer = track.layer.split("->")[0];
        if (!layerVisibility[baseLayer]) return;
        ctx.strokeStyle = net === "VDD" ? "#d22" : "#292";
        ctx.lineWidth = metalLayers.find(l => l.name === baseLayer)?.width || 4;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(track.points[0].x, track.points[0].y);
        for (let i = 1; i < track.points.length; i++)
          ctx.lineTo(track.points[i].x, track.points[i].y);
        ctx.stroke();
      });
    });
  }

  // Draw clock tree network lines (CTS) on M4/M5 layers (automatic)
  function drawCTSNetwork() {
    routedCTSNetwork.forEach(line => {
      if (!layerVisibility[line.layer]) return;
      const col = { "M5": "#297ab9", "M4": "#2ea15a" }[line.layer] || "#2964d0";
      ctx.strokeStyle = col;
      ctx.lineWidth = metalLayers.find(l => l.name === line.layer)?.width || 4;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(line.points[0].x, line.points[0].y);
      for (let i = 1; i < line.points.length; i++)
        ctx.lineTo(line.points[i].x, line.points[i].y);
      ctx.stroke();
    });
  }

  // Draw signal network lines on M3/M2 layers (automatic)
  function drawSignalNetwork() {
    routedDataNetwork.forEach(line => {
      if(!layerVisibility[line.layer]) return;
      const col = { "M3": "#8e44ad", "M2": "#2080d0" }[line.layer] || "#444";
      ctx.strokeStyle = col;
      ctx.lineWidth = metalLayers.find(l => l.name === line.layer)?.width || 3;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(line.points[0].x, line.points[0].y);
      for (let i = 1; i < line.points.length; i++)
        ctx.lineTo(line.points[i].x, line.points[i].y);
      ctx.stroke();
    });
  }

  // Draw manual routes (lines) stored in manualCTSRoutes - works for CTS and signal manual routing
  function drawManualCTSNetwork() {
    manualCTSRoutes.forEach(route => {
      if (!layerVisibility[route.layer]) return;
      ctx.strokeStyle = metalLayers.find(l => l.name === route.layer)?.color || "#666";
      ctx.lineWidth = metalLayers.find(l => l.name === route.layer)?.width || 3;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(route.points[0].x, route.points[0].y);
      for (let i = 1; i < route.points.length; i++)
        ctx.lineTo(route.points[i].x, route.points[i].y);
      ctx.stroke();
    });
    // Draw in-progress manual route (with dashed line)
    if (manualRoutePoints.length > 1) {
      const layer = manualActiveLayer;
      if(layer && layerVisibility[layer]){
        ctx.strokeStyle = metalLayers.find(l => l.name === layer)?.color || "#999";
        ctx.lineWidth = metalLayers.find(l => l.name === layer)?.width || 3;
        ctx.setLineDash([10, 6]);
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(manualRoutePoints[0].x, manualRoutePoints[0].y);
        for (let i = 1; i < manualRoutePoints.length; i++)
          ctx.lineTo(manualRoutePoints[i].x, manualRoutePoints[i].y);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
  }

  // Filtering visible layers for automatic routing according to spec:
  // Only show layers actually used in routing except always show VDD, VSS power distribution layers.
  function filterLayersForCTS(){
    // CTS auto: only M4 and M5 used for clock routing
    // Find used layers in routedCTSNetwork
    const usedLayers = new Set(["M4", "M5"]);
    // Always show VDD and VSS
    layerVisibility = Object.fromEntries(Object.keys(layerVisibility).map(l => {
      if(l === "VDD" || l === "VSS") return [l,true];
      if(usedLayers.has(l)) return [l,true];
      if(l.startsWith("via")) {
        // Show via only if adjacent metal layers used
        let showVia = false;
        if(l === "via45" && usedLayers.has("M4") && usedLayers.has("M5")) showVia = true;
        if(showVia) return [l,true];
        return [l,false];
      }
      return [l,false];
    }));
    // Ensure "all" reflects actual state
    layerVisibility.all = Object.keys(layerVisibility).filter(l => l !== "all").every(l => layerVisibility[l]);
    updateLayerButtons();
  }
  // Filter layers for signal routing auto stage:
  // Signal nets only on M3 (horizontal) and M2 (vertical)
  function filterLayersForSignal(){
    const usedLayers = new Set(["M2","M3"]);
    // Always show VDD and VSS
    layerVisibility = Object.fromEntries(Object.keys(layerVisibility).map(l => {
      if(l === "VDD" || l === "VSS") return [l,true];
      if(usedLayers.has(l)) return [l,true];
      if(l.startsWith("via")) {
        // Show via only if adjacent metal layers used
        let showVia = false;
        if(l === "via12" && usedLayers.has("M1") && usedLayers.has("M2")) showVia = true;
        if(l === "via23" && usedLayers.has("M2") && usedLayers.has("M3")) showVia = true;
        if(showVia) return [l,true];
        return [l,false];
      }
      return [l,false];
    }));
    layerVisibility.all = Object.keys(layerVisibility).filter(l => l !== "all").every(l => layerVisibility[l]);
    updateLayerButtons();
  }

  // Helper for Manhattan routing: returns array of points to simulate L shaped path
  // This creates two segments: first horizontal or vertical, then vertical or horizontal
  function manhattanPointConstrained(start, end, layerOrientation) {
    // If horizontal layer -> line must be horizontal (y fixed)
    // If vertical layer -> line must be vertical (x fixed)
    const points = [];
    if (layerOrientation === "horizontal") {
      points.push({ x: start.x, y: start.y });
      points.push({ x: end.x, y: start.y });
      points.push({ x: end.x, y: end.y });
    } else if (layerOrientation === "vertical") {
      points.push({ x: start.x, y: start.y });
      points.push({ x: start.x, y: end.y });
      points.push({ x: end.x, y: end.y });
    } else {
      // fallback Manhattan path
      points.push({ x: start.x, y: start.y });
      points.push({ x: end.x, y: start.y });
      points.push({ x: end.x, y: end.y });
    }
    return points;
  }

  // Drawing Helpers Continued

  // Draw all power, macro, std cells, ports and routing for display

  // ----- Manual drawing interaction -----

  let draggingBlock = null;
  let dragOffsetX = 0, dragOffsetY = 0;

  canvas.addEventListener("mousedown", e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    if (stage === "macroPlacement") {
      // Macro drag
      draggingBlock = macros.find(b => mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) || null;
      if (draggingBlock) {
        dragOffsetX = mx - draggingBlock.x;
        dragOffsetY = my - draggingBlock.y;
      }
    } else if(stage === "ctsManual" || stage === "routingManual") {
      if (modeSelector.querySelector('input[value="manual"]').checked) {
        // Manual CTS / Routing drawing start/point addition
        handleManualDrawClick(mx, my);
      }
    } else if (stage === "stdCellManual") {
      draggingBlock = stdCells.find(b => mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) || null;
      if (draggingBlock) {
        dragOffsetX = mx - draggingBlock.x;
        dragOffsetY = my - draggingBlock.y;
      }
    }
  });
  canvas.addEventListener("mousemove", e => {
    if (!draggingBlock) return;
    const rect = canvas.getBoundingClientRect();
    let mx = e.clientX - rect.left;
    let my = e.clientY - rect.top;
    let nx = mx - dragOffsetX;
    let ny = my - dragOffsetY;

    // Constrain inside core
    nx = Math.max(core.x, Math.min(nx, core.x + core.w - draggingBlock.w));
    ny = Math.max(core.y, Math.min(ny, core.y + core.h - draggingBlock.h));
    draggingBlock.x = snapToGrid(nx);
    draggingBlock.y = snapToGrid(ny);
    drawAll();
  });
  canvas.addEventListener("mouseup", e => { draggingBlock = null; });
  canvas.addEventListener("mouseleave", e => { draggingBlock = null; });

  // Manual routing drawing click handler
  function handleManualDrawClick(px, py) {
    if (!manualActiveLayer) {
      alert("Select a metal layer for manual routing.");
      return;
    }
    // Constrain points to horizontal or vertical lines according to layer orientation
    const orientation = metalLayers.find(l => l.name === manualActiveLayer)?.orientation || "horizontal";

    if (!manualDrawing) {
      manualDrawing = true;
      manualRoutePoints = [{ x: px, y: py }];
    } else {
      let lastPoint = manualRoutePoints[manualRoutePoints.length - 1];
      let newPoint;
      if (orientation === "horizontal") {
        // Constrain Y same as lastPoint.y
        newPoint = { x: px, y: lastPoint.y };
      } else if (orientation === "vertical") {
        // Constrain X same as lastPoint.x
        newPoint = { x: lastPoint.x, y: py };
      } else {
        newPoint = { x: px, y: py };
      }
      manualRoutePoints.push(newPoint);
    }
    drawAll();
  }

  // Double click on canvas to finish manual route
  canvas.addEventListener("dblclick", e => {
    if (manualDrawing && manualRoutePoints.length >= 2) {
      manualCTSRoutes.push({ layer: manualActiveLayer, points: manualRoutePoints });
      manualRoutePoints = [];
      manualDrawing = false;
      drawAll();
    }
  });

  // Tooltip helpers omitted (unchanged; available from original code)

  // Timer & status code from original retained
  function timerStart() {
    time = 0; score = 0;
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      time++;
      updateStatus();
    }, 1000);
  }

  // PORT COORDINATE Dialog handlers
  function openPortDialog() {
    portForm.vddX.value = powerPorts[0].x;
    portForm.vddY.value = powerPorts[0].y;
    portForm.vssX.value = powerPorts[1].x;
    portForm.vssY.value = powerPorts[1].y;
    portForm.clkX.value = clockPort.x;
    portForm.clkY.value = clockPort.y;
    portForm.dataX.value = dataPorts[0].x;
    portForm.dataY.value = dataPorts[0].y;

    portDialogOverlay.style.display = "flex";
  }
  portForm.addEventListener("submit", e => {
    e.preventDefault();

    const fields = ["vdd", "vss", "clk", "data"];
    for (let f of fields) {
      const x = Number(portForm[`${f}X`].value);
      const y = Number(portForm[`${f}Y`].value);
      if (isNaN(x) || isNaN(y) || x < 0 || y < 0 || x > 300 || y > 820) {
        alert("Port coordinates must be numbers between valid ranges:\nX:0-300, Y:0-820.");
        return;
      }
    }

    powerPorts[0].x = Number(portForm.vddX.value);
    powerPorts[0].y = Number(portForm.vddY.value);
    powerPorts[1].x = Number(portForm.vssX.value);
    powerPorts[1].y = Number(portForm.vssY.value);
    clockPort.x = Number(portForm.clkX.value);
    clockPort.y = Number(portForm.clkY.value);
    dataPorts[0].x = Number(portForm.dataX.value);
    dataPorts[0].y = Number(portForm.dataY.value);

    portDialogOverlay.style.display = "none";

    drawAll();
  });
  portDialogOverlay.addEventListener("click", e => {
    if (e.target === portDialogOverlay)
      portDialogOverlay.style.display = "none";
  });

  // Initialize on page load
  function initialize() {
    initializeGridAndVias();
    routePowerNets();
    buildClockTree();
    buildSignalTree();
    routeSignalNets();
    timerStart();
    updateStatus();
    drawAll();
    populateMetalLayerSelect();
  }

  initialize();

  // Tooltip hover logic from original code can be added here unchanged

  // Expose manhattanPath to allow reuse inside recursion:
  // Already defined above.

})();
</script>
</body>
</html>